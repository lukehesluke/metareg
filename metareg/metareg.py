import math
import random
import re

from . import settings
from .util import generate_until


def does_match(regex, strings):
    ''' Does regex match any from a collection of strings? '''
    return any(re.search(regex, s) for s in strings)


def matched_strings(regex, strings):
    ''' Set of strings matched by regex '''
    return {s for s in strings if re.search(regex, s)}


def random_substring(string):
    ''' Random substring from a string '''
    # Length of string with ^ and $ anchor tags
    length = len(string) + 2
    start_index = random.randrange(length)
    end_index = start_index + min(
        round(settings.substring_length_dist()),
        length - start_index
    )
    substring = re.escape(
        # This seems needlessly complicated, but the idea is that any characters
        # within the string can be escaped without escaping ^ and $ anchor tags
        # and just adding them to the resulting string
        string[max(start_index - 1, 0) : min(end_index - 1, len(string) - 1)]
    )
    if start_index == 0:
        substring = "^" + substring
    if start_index == length - 1:
        substring += "$"
    return substring


def dotify_character(c):
    ''' Randomly return character or a dot '''
    if c in "^$":
        return c
    return "." if random.random() < settings.prob_dotify else c


def regex_characters(regex):
    ''' Yield individual characters from a regex including escaped characters '''
    buffer = ""
    for c in regex:
        buffer += c
        if buffer == "\\":
            continue
        yield buffer
        buffer = ""


def random_regex_component_generator(strings):
    '''
    Generator returning random regex components that match one of a collection
    of strings
    '''
    # Cheaper to get random item from list than set
    string_list = list(strings)
    while True:
        string = random.choice(string_list)
        substring = random_substring(string)
        dotified = "".join(dotify_character(c) for c in regex_characters(substring))
        yield dotified


def regex_components(good_strings, bad_strings):
    '''
    Generate a set of regex components which each match one or more of the
    'good' strings, while matching none of the 'bad'
    '''
    # Whole matches for each string
    wholes = {"^%s$" % (s,) for s in good_strings}
    parts = {
        p for p in generate_until(
            settings.time_limit_regex_components,
            random_regex_component_generator(good_strings)
        ) if not does_match(p, bad_strings)
    }
    return wholes.union(parts)


def greedy_weighted_set_cover(strings, regex_components, greediness_dist=None):
    '''
    Use greedy weighted set cover algorithm to find a reasonably short regex
    that matches all from a collection of strings
    '''
    # If argument not given, the distribution always returns 0
    greediness_dist = greediness_dist or (lambda: 0)
    solution = set()

    def score(regex):
        # Add 1 to weight of all but the first regex in the solution due
        # to the | in regex disjunction
        weight = len(regex) + (1 if solution else 0)
        num_matches = len(matched_strings(regex, strings))
        return (weight / num_matches) if num_matches > 0 else float("+inf")
    while strings:
        regex_components = [
            r for w, r in sorted((
                (score(r), r) for r in regex_components
            ), reverse=True) if w != float("+inf")
        ]
        if not regex_components:
            break  # No set cover could be found
        # If greediness distribution sample returns 0, the last (i.e. best)
        # element will be added to the solution. This would be truly greedy
        greediness = min(len(regex_components) - 1, round(greediness_dist()))
        best_regex = regex_components.pop(-1 - greediness)
        solution.add(best_regex)
        strings = strings.difference(matched_strings(best_regex, strings))
    return solution


def neighbour_solution(solution, strings, regex_components):
    '''
    Generate a neighbour solution to a currently acceptable solution
    A neighbour is generated by removing a random number of regexes from the
    current solution and then running a randomized weighted set cover algorithm
    on this partial solution
    '''
    num_patterns_to_remove = min(
        round(settings.neighbour_remove_regex_dist()),
        # Don't remove more solutions than in the solution
        len(solution) - 1
    )
    num_patterns_to_keep = len(solution) - num_patterns_to_remove
    partial_solution = set(random.sample(solution, num_patterns_to_keep))
    unmatched_strings = strings - set.union(*(
        matched_strings(r, strings) for r in partial_solution
    ))
    partial_solution.update(greedy_weighted_set_cover(
        unmatched_strings,
        regex_components - partial_solution,
        settings.neighbour_greediness_dist
    ))
    return partial_solution


def move_to_neighbour_solution(current, neighbour, inverse_temperature):
    '''
    Whether or not to move to a neighbour solution in simulated annealing.
    '''
    energy_delta = len("|".join(neighbour)) - len("|".join(current))
    # Always move if neighbour is in a lower energy state
    if energy_delta <= 0:
        return True
    inertia = -energy_delta * inverse_temperature   # Resistance to change
    return random.random() < math.exp(inertia)


def simulated_annealing_generator(solution, good_strings, bad_strings, regex_components):
    '''
    Use simulated annealing to generate improved solutions after greedy
    search
    '''
    inverse_temperature = 0.0
    while True:
        neighbour = neighbour_solution(solution, good_strings, regex_components)
        move_to_neighbour = (
            verify("|".join(neighbour), good_strings, bad_strings) and
            move_to_neighbour_solution(solution, neighbour, inverse_temperature)
        )
        if move_to_neighbour:
            solution = neighbour
        inverse_temperature = (yield solution)


def verify(regex, good_strings, bad_strings):
    ''' Verify that regex matches all good strings but no bad '''
    return (
        all(re.search(regex, s) for s in good_strings) and
        not does_match(regex, bad_strings)
    )


def find_regex(good_strings, bad_strings):
    ''' Find short regex to match all good strings but no bad '''
    components = regex_components(good_strings, bad_strings)
    cover = greedy_weighted_set_cover(good_strings, components)
    simulated_annealer = generate_until(
        settings.time_limit_simulated_annealing,
        simulated_annealing_generator(cover, good_strings, bad_strings, components)
    )
    improved = min(simulated_annealer, key=lambda s: len("|".join(s)))
    return "|".join(improved)
